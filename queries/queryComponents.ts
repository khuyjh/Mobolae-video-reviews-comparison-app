/**
 * Generated by @openapi-codegen
 *
 * @version 1.0.0
 */
import * as reactQuery from '@tanstack/react-query';

import { useQueryContext, QueryContext, queryKeyFn } from './queryContext';
import { queryFetch } from './queryFetcher';
import { deepMerge } from './queryUtils';

import type * as Fetcher from './queryFetcher';
import type * as Schemas from './querySchemas';

type QueryFnOptions = {
  signal?: AbortController['signal'];
};

export type MePathParams = {
  teamId: string;
};

export type MeError = Fetcher.ErrorWrapper<undefined>;

export type MeVariables = {
  pathParams: MePathParams;
} & QueryContext['fetcherOptions'];

/**
 * 내 정보 조회
 */
export const fetchMe = (variables: MeVariables, signal?: AbortSignal) =>
  queryFetch<Schemas.UserDetail, MeError, undefined, {}, {}, MePathParams>({
    url: '/{teamId}/users/me',
    method: 'get',
    ...variables,
    signal,
  });

/**
 * 내 정보 조회
 */
export function meQuery(variables: MeVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.UserDetail>;
};

export function meQuery(variables: MeVariables | reactQuery.SkipToken): {
  queryKey: reactQuery.QueryKey;
  queryFn: ((options: QueryFnOptions) => Promise<Schemas.UserDetail>) | reactQuery.SkipToken;
};

export function meQuery(variables: MeVariables | reactQuery.SkipToken) {
  return {
    queryKey: queryKeyFn({
      path: '/{teamId}/users/me',
      operationId: 'me',
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchMe(variables, signal),
  };
}

/**
 * 내 정보 조회
 */
export const useSuspenseMe = <TData = Schemas.UserDetail>(
  variables: MeVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.UserDetail, MeError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueryContext(options);
  return reactQuery.useSuspenseQuery<Schemas.UserDetail, MeError, TData>({
    ...meQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * 내 정보 조회
 */
export const useMe = <TData = Schemas.UserDetail>(
  variables: MeVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.UserDetail, MeError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueryContext(options);
  return reactQuery.useQuery<Schemas.UserDetail, MeError, TData>({
    ...meQuery(
      variables === reactQuery.skipToken ? variables : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type UpdateMePathParams = {
  teamId: string;
};

export type UpdateMeError = Fetcher.ErrorWrapper<undefined>;

export type UpdateMeResponse = {
  /**
   * @format date-time
   */
  updatedAt?: string;
  /**
   * @format date-time
   */
  createdAt: string;
  teamId: string;
  /**
   * @example https://example.com/...
   * @format url
   * @pattern ^https?://.+
   */
  image: Schemas.UrlType | null;
  description: string;
  nickname: string;
  id: Schemas.Id;
};

export type UpdateMeVariables = {
  body?: Schemas.UpdateUserRequestBody;
  pathParams: UpdateMePathParams;
} & QueryContext['fetcherOptions'];

/**
 * 내 정보 수정
 */
export const fetchUpdateMe = (variables: UpdateMeVariables, signal?: AbortSignal) =>
  queryFetch<
    UpdateMeResponse,
    UpdateMeError,
    Schemas.UpdateUserRequestBody,
    {},
    {},
    UpdateMePathParams
  >({ url: '/{teamId}/users/me', method: 'patch', ...variables, signal });

/**
 * 내 정보 수정
 */
export const useUpdateMe = (
  options?: Omit<
    reactQuery.UseMutationOptions<UpdateMeResponse, UpdateMeError, UpdateMeVariables>,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useQueryContext();
  return reactQuery.useMutation<UpdateMeResponse, UpdateMeError, UpdateMeVariables>({
    mutationFn: (variables: UpdateMeVariables) =>
      fetchUpdateMe(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type UserRankingPathParams = {
  teamId: string;
};

export type UserRankingError = Fetcher.ErrorWrapper<undefined>;

export type UserRankingResponse = Schemas.UserRanking[];

export type UserRankingVariables = {
  pathParams: UserRankingPathParams;
} & QueryContext['fetcherOptions'];

/**
 * 유저 랭킹 조회
 */
export const fetchUserRanking = (variables: UserRankingVariables, signal?: AbortSignal) =>
  queryFetch<UserRankingResponse, UserRankingError, undefined, {}, {}, UserRankingPathParams>({
    url: '/{teamId}/users/ranking',
    method: 'get',
    ...variables,
    signal,
  });

/**
 * 유저 랭킹 조회
 */
export function userRankingQuery(variables: UserRankingVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<UserRankingResponse>;
};

export function userRankingQuery(variables: UserRankingVariables | reactQuery.SkipToken): {
  queryKey: reactQuery.QueryKey;
  queryFn: ((options: QueryFnOptions) => Promise<UserRankingResponse>) | reactQuery.SkipToken;
};

export function userRankingQuery(variables: UserRankingVariables | reactQuery.SkipToken) {
  return {
    queryKey: queryKeyFn({
      path: '/{teamId}/users/ranking',
      operationId: 'userRanking',
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchUserRanking(variables, signal),
  };
}

/**
 * 유저 랭킹 조회
 */
export const useSuspenseUserRanking = <TData = UserRankingResponse>(
  variables: UserRankingVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<UserRankingResponse, UserRankingError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueryContext(options);
  return reactQuery.useSuspenseQuery<UserRankingResponse, UserRankingError, TData>({
    ...userRankingQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * 유저 랭킹 조회
 */
export const useUserRanking = <TData = UserRankingResponse>(
  variables: UserRankingVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<UserRankingResponse, UserRankingError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueryContext(options);
  return reactQuery.useQuery<UserRankingResponse, UserRankingError, TData>({
    ...userRankingQuery(
      variables === reactQuery.skipToken ? variables : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type UserDetailPathParams = {
  teamId: string;
  /**
   * @format double
   */
  userId: number;
};

export type UserDetailError = Fetcher.ErrorWrapper<undefined>;

export type UserDetailVariables = {
  pathParams: UserDetailPathParams;
} & QueryContext['fetcherOptions'];

/**
 * 유저 정보 조회
 */
export const fetchUserDetail = (variables: UserDetailVariables, signal?: AbortSignal) =>
  queryFetch<Schemas.UserDetail, UserDetailError, undefined, {}, {}, UserDetailPathParams>({
    url: '/{teamId}/users/{userId}',
    method: 'get',
    ...variables,
    signal,
  });

/**
 * 유저 정보 조회
 */
export function userDetailQuery(variables: UserDetailVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.UserDetail>;
};

export function userDetailQuery(variables: UserDetailVariables | reactQuery.SkipToken): {
  queryKey: reactQuery.QueryKey;
  queryFn: ((options: QueryFnOptions) => Promise<Schemas.UserDetail>) | reactQuery.SkipToken;
};

export function userDetailQuery(variables: UserDetailVariables | reactQuery.SkipToken) {
  return {
    queryKey: queryKeyFn({
      path: '/{teamId}/users/{userId}',
      operationId: 'userDetail',
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchUserDetail(variables, signal),
  };
}

/**
 * 유저 정보 조회
 */
export const useSuspenseUserDetail = <TData = Schemas.UserDetail>(
  variables: UserDetailVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.UserDetail, UserDetailError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueryContext(options);
  return reactQuery.useSuspenseQuery<Schemas.UserDetail, UserDetailError, TData>({
    ...userDetailQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * 유저 정보 조회
 */
export const useUserDetail = <TData = Schemas.UserDetail>(
  variables: UserDetailVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.UserDetail, UserDetailError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueryContext(options);
  return reactQuery.useQuery<Schemas.UserDetail, UserDetailError, TData>({
    ...userDetailQuery(
      variables === reactQuery.skipToken ? variables : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type ListUserCreatedProductsPathParams = {
  /**
   * @format double
   */
  userId: number;
};

export type ListUserCreatedProductsQueryParams = {
  /**
   * 다음 페이지를 위한 커서
   *
   * @format double
   */
  cursor?: number;
};

export type ListUserCreatedProductsError = Fetcher.ErrorWrapper<undefined>;

export type ListUserCreatedProductsVariables = {
  pathParams: ListUserCreatedProductsPathParams;
  queryParams?: ListUserCreatedProductsQueryParams;
} & QueryContext['fetcherOptions'];

/**
 * 유저가 생성한 상품 조회
 */
export const fetchListUserCreatedProducts = (
  variables: ListUserCreatedProductsVariables,
  signal?: AbortSignal,
) =>
  queryFetch<
    Schemas.CursorBasedPaginationResponseProductListType,
    ListUserCreatedProductsError,
    undefined,
    {},
    ListUserCreatedProductsQueryParams,
    ListUserCreatedProductsPathParams
  >({
    url: '/{teamId}/users/{userId}/created-products',
    method: 'get',
    ...variables,
    signal,
  });

/**
 * 유저가 생성한 상품 조회
 */
export function listUserCreatedProductsQuery(variables: ListUserCreatedProductsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<Schemas.CursorBasedPaginationResponseProductListType>;
};

export function listUserCreatedProductsQuery(
  variables: ListUserCreatedProductsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.CursorBasedPaginationResponseProductListType>)
    | reactQuery.SkipToken;
};

export function listUserCreatedProductsQuery(
  variables: ListUserCreatedProductsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: '/{teamId}/users/{userId}/created-products',
      operationId: 'listUserCreatedProducts',
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchListUserCreatedProducts(variables, signal),
  };
}

/**
 * 유저가 생성한 상품 조회
 */
export const useSuspenseListUserCreatedProducts = <
  TData = Schemas.CursorBasedPaginationResponseProductListType,
>(
  variables: ListUserCreatedProductsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.CursorBasedPaginationResponseProductListType,
      ListUserCreatedProductsError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueryContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.CursorBasedPaginationResponseProductListType,
    ListUserCreatedProductsError,
    TData
  >({
    ...listUserCreatedProductsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * 유저가 생성한 상품 조회
 */
export const useListUserCreatedProducts = <
  TData = Schemas.CursorBasedPaginationResponseProductListType,
>(
  variables: ListUserCreatedProductsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.CursorBasedPaginationResponseProductListType,
      ListUserCreatedProductsError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueryContext(options);
  return reactQuery.useQuery<
    Schemas.CursorBasedPaginationResponseProductListType,
    ListUserCreatedProductsError,
    TData
  >({
    ...listUserCreatedProductsQuery(
      variables === reactQuery.skipToken ? variables : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type ListUserReviewedProductsPathParams = {
  /**
   * @format double
   */
  userId: number;
};

export type ListUserReviewedProductsQueryParams = {
  /**
   * 다음 페이지를 위한 커서
   *
   * @format double
   */
  cursor?: number;
};

export type ListUserReviewedProductsError = Fetcher.ErrorWrapper<undefined>;

export type ListUserReviewedProductsVariables = {
  pathParams: ListUserReviewedProductsPathParams;
  queryParams?: ListUserReviewedProductsQueryParams;
} & QueryContext['fetcherOptions'];

/**
 * 유저가 리뷰한 상품 조회
 */
export const fetchListUserReviewedProducts = (
  variables: ListUserReviewedProductsVariables,
  signal?: AbortSignal,
) =>
  queryFetch<
    Schemas.CursorBasedPaginationResponseProductListType,
    ListUserReviewedProductsError,
    undefined,
    {},
    ListUserReviewedProductsQueryParams,
    ListUserReviewedProductsPathParams
  >({
    url: '/{teamId}/users/{userId}/reviewed-products',
    method: 'get',
    ...variables,
    signal,
  });

/**
 * 유저가 리뷰한 상품 조회
 */
export function listUserReviewedProductsQuery(variables: ListUserReviewedProductsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<Schemas.CursorBasedPaginationResponseProductListType>;
};

export function listUserReviewedProductsQuery(
  variables: ListUserReviewedProductsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.CursorBasedPaginationResponseProductListType>)
    | reactQuery.SkipToken;
};

export function listUserReviewedProductsQuery(
  variables: ListUserReviewedProductsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: '/{teamId}/users/{userId}/reviewed-products',
      operationId: 'listUserReviewedProducts',
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchListUserReviewedProducts(variables, signal),
  };
}

/**
 * 유저가 리뷰한 상품 조회
 */
export const useSuspenseListUserReviewedProducts = <
  TData = Schemas.CursorBasedPaginationResponseProductListType,
>(
  variables: ListUserReviewedProductsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.CursorBasedPaginationResponseProductListType,
      ListUserReviewedProductsError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueryContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.CursorBasedPaginationResponseProductListType,
    ListUserReviewedProductsError,
    TData
  >({
    ...listUserReviewedProductsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * 유저가 리뷰한 상품 조회
 */
export const useListUserReviewedProducts = <
  TData = Schemas.CursorBasedPaginationResponseProductListType,
>(
  variables: ListUserReviewedProductsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.CursorBasedPaginationResponseProductListType,
      ListUserReviewedProductsError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueryContext(options);
  return reactQuery.useQuery<
    Schemas.CursorBasedPaginationResponseProductListType,
    ListUserReviewedProductsError,
    TData
  >({
    ...listUserReviewedProductsQuery(
      variables === reactQuery.skipToken ? variables : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type ListUserFavoriteProductsPathParams = {
  /**
   * @format double
   */
  userId: number;
};

export type ListUserFavoriteProductsQueryParams = {
  /**
   * 다음 페이지를 위한 커서
   *
   * @format double
   */
  cursor?: number;
};

export type ListUserFavoriteProductsError = Fetcher.ErrorWrapper<undefined>;

export type ListUserFavoriteProductsVariables = {
  pathParams: ListUserFavoriteProductsPathParams;
  queryParams?: ListUserFavoriteProductsQueryParams;
} & QueryContext['fetcherOptions'];

/**
 * 유저가 찜한 상품 조회
 */
export const fetchListUserFavoriteProducts = (
  variables: ListUserFavoriteProductsVariables,
  signal?: AbortSignal,
) =>
  queryFetch<
    Schemas.CursorBasedPaginationResponseProductListType,
    ListUserFavoriteProductsError,
    undefined,
    {},
    ListUserFavoriteProductsQueryParams,
    ListUserFavoriteProductsPathParams
  >({
    url: '/{teamId}/users/{userId}/favorite-products',
    method: 'get',
    ...variables,
    signal,
  });

/**
 * 유저가 찜한 상품 조회
 */
export function listUserFavoriteProductsQuery(variables: ListUserFavoriteProductsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<Schemas.CursorBasedPaginationResponseProductListType>;
};

export function listUserFavoriteProductsQuery(
  variables: ListUserFavoriteProductsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.CursorBasedPaginationResponseProductListType>)
    | reactQuery.SkipToken;
};

export function listUserFavoriteProductsQuery(
  variables: ListUserFavoriteProductsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: '/{teamId}/users/{userId}/favorite-products',
      operationId: 'listUserFavoriteProducts',
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchListUserFavoriteProducts(variables, signal),
  };
}

/**
 * 유저가 찜한 상품 조회
 */
export const useSuspenseListUserFavoriteProducts = <
  TData = Schemas.CursorBasedPaginationResponseProductListType,
>(
  variables: ListUserFavoriteProductsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.CursorBasedPaginationResponseProductListType,
      ListUserFavoriteProductsError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueryContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.CursorBasedPaginationResponseProductListType,
    ListUserFavoriteProductsError,
    TData
  >({
    ...listUserFavoriteProductsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * 유저가 찜한 상품 조회
 */
export const useListUserFavoriteProducts = <
  TData = Schemas.CursorBasedPaginationResponseProductListType,
>(
  variables: ListUserFavoriteProductsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.CursorBasedPaginationResponseProductListType,
      ListUserFavoriteProductsError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueryContext(options);
  return reactQuery.useQuery<
    Schemas.CursorBasedPaginationResponseProductListType,
    ListUserFavoriteProductsError,
    TData
  >({
    ...listUserFavoriteProductsQuery(
      variables === reactQuery.skipToken ? variables : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type ListUserFolloweesPathParams = {
  /**
   * @format double
   */
  userId: number;
};

export type ListUserFolloweesQueryParams = {
  /**
   * @format double
   */
  cursor?: number;
};

export type ListUserFolloweesError = Fetcher.ErrorWrapper<undefined>;

export type ListUserFolloweesVariables = {
  pathParams: ListUserFolloweesPathParams;
  queryParams?: ListUserFolloweesQueryParams;
} & QueryContext['fetcherOptions'];

/**
 * 유저가 팔로우한 유저 조회
 */
export const fetchListUserFollowees = (
  variables: ListUserFolloweesVariables,
  signal?: AbortSignal,
) =>
  queryFetch<
    Schemas.CursorBasedPaginationResponseIdNumberFolloweeUser,
    ListUserFolloweesError,
    undefined,
    {},
    ListUserFolloweesQueryParams,
    ListUserFolloweesPathParams
  >({
    url: '/{teamId}/users/{userId}/followees',
    method: 'get',
    ...variables,
    signal,
  });

/**
 * 유저가 팔로우한 유저 조회
 */
export function listUserFolloweesQuery(variables: ListUserFolloweesVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<Schemas.CursorBasedPaginationResponseIdNumberFolloweeUser>;
};

export function listUserFolloweesQuery(
  variables: ListUserFolloweesVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<Schemas.CursorBasedPaginationResponseIdNumberFolloweeUser>)
    | reactQuery.SkipToken;
};

export function listUserFolloweesQuery(
  variables: ListUserFolloweesVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: '/{teamId}/users/{userId}/followees',
      operationId: 'listUserFollowees',
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchListUserFollowees(variables, signal),
  };
}

/**
 * 유저가 팔로우한 유저 조회
 */
export const useSuspenseListUserFollowees = <
  TData = Schemas.CursorBasedPaginationResponseIdNumberFolloweeUser,
>(
  variables: ListUserFolloweesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.CursorBasedPaginationResponseIdNumberFolloweeUser,
      ListUserFolloweesError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueryContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.CursorBasedPaginationResponseIdNumberFolloweeUser,
    ListUserFolloweesError,
    TData
  >({
    ...listUserFolloweesQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * 유저가 팔로우한 유저 조회
 */
export const useListUserFollowees = <
  TData = Schemas.CursorBasedPaginationResponseIdNumberFolloweeUser,
>(
  variables: ListUserFolloweesVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.CursorBasedPaginationResponseIdNumberFolloweeUser,
      ListUserFolloweesError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueryContext(options);
  return reactQuery.useQuery<
    Schemas.CursorBasedPaginationResponseIdNumberFolloweeUser,
    ListUserFolloweesError,
    TData
  >({
    ...listUserFolloweesQuery(
      variables === reactQuery.skipToken ? variables : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type ListUserFollowersPathParams = {
  /**
   * @format double
   */
  userId: number;
};

export type ListUserFollowersQueryParams = {
  /**
   * @format double
   */
  cursor?: number;
};

export type ListUserFollowersError = Fetcher.ErrorWrapper<undefined>;

export type ListUserFollowersVariables = {
  pathParams: ListUserFollowersPathParams;
  queryParams?: ListUserFollowersQueryParams;
} & QueryContext['fetcherOptions'];

/**
 * 유저를 팔로우한 유저 조회
 */
export const fetchListUserFollowers = (
  variables: ListUserFollowersVariables,
  signal?: AbortSignal,
) =>
  queryFetch<
    Schemas.CursorBasedPaginationResponseIdNumberFollowerUser,
    ListUserFollowersError,
    undefined,
    {},
    ListUserFollowersQueryParams,
    ListUserFollowersPathParams
  >({
    url: '/{teamId}/users/{userId}/followers',
    method: 'get',
    ...variables,
    signal,
  });

/**
 * 유저를 팔로우한 유저 조회
 */
export function listUserFollowersQuery(variables: ListUserFollowersVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<Schemas.CursorBasedPaginationResponseIdNumberFollowerUser>;
};

export function listUserFollowersQuery(
  variables: ListUserFollowersVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<Schemas.CursorBasedPaginationResponseIdNumberFollowerUser>)
    | reactQuery.SkipToken;
};

export function listUserFollowersQuery(
  variables: ListUserFollowersVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: '/{teamId}/users/{userId}/followers',
      operationId: 'listUserFollowers',
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchListUserFollowers(variables, signal),
  };
}

/**
 * 유저를 팔로우한 유저 조회
 */
export const useSuspenseListUserFollowers = <
  TData = Schemas.CursorBasedPaginationResponseIdNumberFollowerUser,
>(
  variables: ListUserFollowersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.CursorBasedPaginationResponseIdNumberFollowerUser,
      ListUserFollowersError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueryContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.CursorBasedPaginationResponseIdNumberFollowerUser,
    ListUserFollowersError,
    TData
  >({
    ...listUserFollowersQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * 유저를 팔로우한 유저 조회
 */
export const useListUserFollowers = <
  TData = Schemas.CursorBasedPaginationResponseIdNumberFollowerUser,
>(
  variables: ListUserFollowersVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.CursorBasedPaginationResponseIdNumberFollowerUser,
      ListUserFollowersError,
      TData
    >,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueryContext(options);
  return reactQuery.useQuery<
    Schemas.CursorBasedPaginationResponseIdNumberFollowerUser,
    ListUserFollowersError,
    TData
  >({
    ...listUserFollowersQuery(
      variables === reactQuery.skipToken ? variables : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type LikeReviewPathParams = {
  teamId: string;
  /**
   * @format double
   */
  reviewId: number;
};

export type LikeReviewError = Fetcher.ErrorWrapper<undefined>;

export type LikeReviewVariables = {
  pathParams: LikeReviewPathParams;
} & QueryContext['fetcherOptions'];

/**
 * 리뷰 좋아요
 */
export const fetchLikeReview = (variables: LikeReviewVariables, signal?: AbortSignal) =>
  queryFetch<Schemas.Review, LikeReviewError, undefined, {}, {}, LikeReviewPathParams>({
    url: '/{teamId}/reviews/{reviewId}/like',
    method: 'post',
    ...variables,
    signal,
  });

/**
 * 리뷰 좋아요
 */
export const useLikeReview = (
  options?: Omit<
    reactQuery.UseMutationOptions<Schemas.Review, LikeReviewError, LikeReviewVariables>,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useQueryContext();
  return reactQuery.useMutation<Schemas.Review, LikeReviewError, LikeReviewVariables>({
    mutationFn: (variables: LikeReviewVariables) =>
      fetchLikeReview(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type UnlikeReviewPathParams = {
  teamId: string;
  /**
   * @format double
   */
  reviewId: number;
};

export type UnlikeReviewError = Fetcher.ErrorWrapper<undefined>;

export type UnlikeReviewVariables = {
  pathParams: UnlikeReviewPathParams;
} & QueryContext['fetcherOptions'];

/**
 * 리뷰 좋아요 취소
 */
export const fetchUnlikeReview = (variables: UnlikeReviewVariables, signal?: AbortSignal) =>
  queryFetch<Schemas.Review, UnlikeReviewError, undefined, {}, {}, UnlikeReviewPathParams>({
    url: '/{teamId}/reviews/{reviewId}/like',
    method: 'delete',
    ...variables,
    signal,
  });

/**
 * 리뷰 좋아요 취소
 */
export const useUnlikeReview = (
  options?: Omit<
    reactQuery.UseMutationOptions<Schemas.Review, UnlikeReviewError, UnlikeReviewVariables>,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useQueryContext();
  return reactQuery.useMutation<Schemas.Review, UnlikeReviewError, UnlikeReviewVariables>({
    mutationFn: (variables: UnlikeReviewVariables) =>
      fetchUnlikeReview(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type CreateReviewPathParams = {
  teamId: string;
};

export type CreateReviewError = Fetcher.ErrorWrapper<undefined>;

export type CreateReviewVariables = {
  body: Schemas.CreateReviewRequestBody;
  pathParams: CreateReviewPathParams;
} & QueryContext['fetcherOptions'];

/**
 * 리뷰 생성
 */
export const fetchCreateReview = (variables: CreateReviewVariables, signal?: AbortSignal) =>
  queryFetch<
    Schemas.Review,
    CreateReviewError,
    Schemas.CreateReviewRequestBody,
    {},
    {},
    CreateReviewPathParams
  >({ url: '/{teamId}/reviews', method: 'post', ...variables, signal });

/**
 * 리뷰 생성
 */
export const useCreateReview = (
  options?: Omit<
    reactQuery.UseMutationOptions<Schemas.Review, CreateReviewError, CreateReviewVariables>,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useQueryContext();
  return reactQuery.useMutation<Schemas.Review, CreateReviewError, CreateReviewVariables>({
    mutationFn: (variables: CreateReviewVariables) =>
      fetchCreateReview(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DeleteReviewPathParams = {
  /**
   * @format double
   */
  reviewId: number;
  teamId: string;
};

export type DeleteReviewError = Fetcher.ErrorWrapper<undefined>;

export type DeleteReviewResponse = {
  /**
   * @format double
   */
  productId: number;
  /**
   * @format double
   */
  userId: number;
  /**
   * @format date-time
   */
  updatedAt: string;
  /**
   * @format date-time
   */
  createdAt: string;
  /**
   * @format double
   */
  likeCount: number;
  /**
   * @format double
   */
  rating: number;
  content: string;
  /**
   * @format double
   */
  id: number;
};

export type DeleteReviewVariables = {
  pathParams: DeleteReviewPathParams;
} & QueryContext['fetcherOptions'];

/**
 * 리뷰 삭제
 */
export const fetchDeleteReview = (variables: DeleteReviewVariables, signal?: AbortSignal) =>
  queryFetch<DeleteReviewResponse, DeleteReviewError, undefined, {}, {}, DeleteReviewPathParams>({
    url: '/{teamId}/reviews/{reviewId}',
    method: 'delete',
    ...variables,
    signal,
  });

/**
 * 리뷰 삭제
 */
export const useDeleteReview = (
  options?: Omit<
    reactQuery.UseMutationOptions<DeleteReviewResponse, DeleteReviewError, DeleteReviewVariables>,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useQueryContext();
  return reactQuery.useMutation<DeleteReviewResponse, DeleteReviewError, DeleteReviewVariables>({
    mutationFn: (variables: DeleteReviewVariables) =>
      fetchDeleteReview(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type UpdateReviewPathParams = {
  /**
   * @format double
   */
  reviewId: number;
  teamId: string;
};

export type UpdateReviewError = Fetcher.ErrorWrapper<undefined>;

export type UpdateReviewVariables = {
  body?: Schemas.UpdateReviewRequestBody;
  pathParams: UpdateReviewPathParams;
} & QueryContext['fetcherOptions'];

/**
 * 리뷰 수정 <br/>
 * 이미지를 수정할 때, 기존 이미지를 유지하려면 id를, 새로운 이미지를 추가하려면 source를 넣어주세요. <br />
 * 요청에 포함되지 않는 기존 이미지는 삭제됩니다.
 */
export const fetchUpdateReview = (variables: UpdateReviewVariables, signal?: AbortSignal) =>
  queryFetch<
    Schemas.Review,
    UpdateReviewError,
    Schemas.UpdateReviewRequestBody,
    {},
    {},
    UpdateReviewPathParams
  >({
    url: '/{teamId}/reviews/{reviewId}',
    method: 'patch',
    ...variables,
    signal,
  });

/**
 * 리뷰 수정 <br/>
 * 이미지를 수정할 때, 기존 이미지를 유지하려면 id를, 새로운 이미지를 추가하려면 source를 넣어주세요. <br />
 * 요청에 포함되지 않는 기존 이미지는 삭제됩니다.
 */
export const useUpdateReview = (
  options?: Omit<
    reactQuery.UseMutationOptions<Schemas.Review, UpdateReviewError, UpdateReviewVariables>,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useQueryContext();
  return reactQuery.useMutation<Schemas.Review, UpdateReviewError, UpdateReviewVariables>({
    mutationFn: (variables: UpdateReviewVariables) =>
      fetchUpdateReview(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type ListProductPathParams = {
  /**
   * 팀 ID
   */
  teamId: string;
};

export type ListProductQueryParams = {
  /**
   * 상품명 검색 키워드
   */
  keyword?: string;
  /**
   * 카테고리 ID
   *
   * @format double
   */
  category?: number;
  order?: 'recent' | 'rating' | 'reviewCount';
  /**
   * 다음 페이지를 위한 커서
   *
   * @format double
   */
  cursor?: number;
};

export type ListProductError = Fetcher.ErrorWrapper<undefined>;

export type ListProductVariables = {
  pathParams: ListProductPathParams;
  queryParams?: ListProductQueryParams;
} & QueryContext['fetcherOptions'];

/**
 * 상품 목록 조회
 */
export const fetchListProduct = (variables: ListProductVariables, signal?: AbortSignal) =>
  queryFetch<
    Schemas.SearchProductResponse,
    ListProductError,
    undefined,
    {},
    ListProductQueryParams,
    ListProductPathParams
  >({ url: '/{teamId}/products', method: 'get', ...variables, signal });

/**
 * 상품 목록 조회
 */
export function listProductQuery(variables: ListProductVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.SearchProductResponse>;
};

export function listProductQuery(variables: ListProductVariables | reactQuery.SkipToken): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.SearchProductResponse>)
    | reactQuery.SkipToken;
};

export function listProductQuery(variables: ListProductVariables | reactQuery.SkipToken) {
  return {
    queryKey: queryKeyFn({
      path: '/{teamId}/products',
      operationId: 'listProduct',
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchListProduct(variables, signal),
  };
}

/**
 * 상품 목록 조회
 */
export const useSuspenseListProduct = <TData = Schemas.SearchProductResponse>(
  variables: ListProductVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.SearchProductResponse, ListProductError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueryContext(options);
  return reactQuery.useSuspenseQuery<Schemas.SearchProductResponse, ListProductError, TData>({
    ...listProductQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * 상품 목록 조회
 */
export const useListProduct = <TData = Schemas.SearchProductResponse>(
  variables: ListProductVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.SearchProductResponse, ListProductError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueryContext(options);
  return reactQuery.useQuery<Schemas.SearchProductResponse, ListProductError, TData>({
    ...listProductQuery(
      variables === reactQuery.skipToken ? variables : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type CreateProductPathParams = {
  teamId: string;
};

export type CreateProductError = Fetcher.ErrorWrapper<undefined>;

export type CreateProductVariables = {
  body: Schemas.CreateProductRequestBody;
  pathParams: CreateProductPathParams;
} & QueryContext['fetcherOptions'];

/**
 * 상품 생성
 */
export const fetchCreateProduct = (variables: CreateProductVariables, signal?: AbortSignal) =>
  queryFetch<
    Schemas.ProductDetailType,
    CreateProductError,
    Schemas.CreateProductRequestBody,
    {},
    {},
    CreateProductPathParams
  >({ url: '/{teamId}/products', method: 'post', ...variables, signal });

/**
 * 상품 생성
 */
export const useCreateProduct = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ProductDetailType,
      CreateProductError,
      CreateProductVariables
    >,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useQueryContext();
  return reactQuery.useMutation<
    Schemas.ProductDetailType,
    CreateProductError,
    CreateProductVariables
  >({
    mutationFn: (variables: CreateProductVariables) =>
      fetchCreateProduct(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type RetrieveProductPathParams = {
  /**
   * @format double
   */
  productId: number;
  teamId: string;
};

export type RetrieveProductError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    message: string;
  };
}>;

export type RetrieveProductVariables = {
  pathParams: RetrieveProductPathParams;
} & QueryContext['fetcherOptions'];

/**
 * 상품 상세 조회
 */
export const fetchRetrieveProduct = (variables: RetrieveProductVariables, signal?: AbortSignal) =>
  queryFetch<
    Schemas.ProductDetailType,
    RetrieveProductError,
    undefined,
    {},
    {},
    RetrieveProductPathParams
  >({
    url: '/{teamId}/products/{productId}',
    method: 'get',
    ...variables,
    signal,
  });

/**
 * 상품 상세 조회
 */
export function retrieveProductQuery(variables: RetrieveProductVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.ProductDetailType>;
};

export function retrieveProductQuery(variables: RetrieveProductVariables | reactQuery.SkipToken): {
  queryKey: reactQuery.QueryKey;
  queryFn: ((options: QueryFnOptions) => Promise<Schemas.ProductDetailType>) | reactQuery.SkipToken;
};

export function retrieveProductQuery(variables: RetrieveProductVariables | reactQuery.SkipToken) {
  return {
    queryKey: queryKeyFn({
      path: '/{teamId}/products/{productId}',
      operationId: 'retrieveProduct',
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchRetrieveProduct(variables, signal),
  };
}

/**
 * 상품 상세 조회
 */
export const useSuspenseRetrieveProduct = <TData = Schemas.ProductDetailType>(
  variables: RetrieveProductVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.ProductDetailType, RetrieveProductError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueryContext(options);
  return reactQuery.useSuspenseQuery<Schemas.ProductDetailType, RetrieveProductError, TData>({
    ...retrieveProductQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * 상품 상세 조회
 */
export const useRetrieveProduct = <TData = Schemas.ProductDetailType>(
  variables: RetrieveProductVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.ProductDetailType, RetrieveProductError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueryContext(options);
  return reactQuery.useQuery<Schemas.ProductDetailType, RetrieveProductError, TData>({
    ...retrieveProductQuery(
      variables === reactQuery.skipToken ? variables : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type UpdateProductPathParams = {
  /**
   * @format double
   */
  productId: number;
  teamId: string;
};

export type UpdateProductError = Fetcher.ErrorWrapper<undefined>;

export type UpdateProductVariables = {
  body: Schemas.UpdateProductRequestBody;
  pathParams: UpdateProductPathParams;
} & QueryContext['fetcherOptions'];

/**
 * 상품 수정
 */
export const fetchUpdateProduct = (variables: UpdateProductVariables, signal?: AbortSignal) =>
  queryFetch<
    Schemas.ProductDetailType,
    UpdateProductError,
    Schemas.UpdateProductRequestBody,
    {},
    {},
    UpdateProductPathParams
  >({
    url: '/{teamId}/products/{productId}',
    method: 'patch',
    ...variables,
    signal,
  });

/**
 * 상품 수정
 */
export const useUpdateProduct = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ProductDetailType,
      UpdateProductError,
      UpdateProductVariables
    >,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useQueryContext();
  return reactQuery.useMutation<
    Schemas.ProductDetailType,
    UpdateProductError,
    UpdateProductVariables
  >({
    mutationFn: (variables: UpdateProductVariables) =>
      fetchUpdateProduct(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DeleteProductPathParams = {
  /**
   * @format double
   */
  productId: number;
  teamId: string;
};

export type DeleteProductError = Fetcher.ErrorWrapper<undefined>;

export type DeleteProductResponse = {
  /**
   * @format double
   */
  id: number;
};

export type DeleteProductVariables = {
  pathParams: DeleteProductPathParams;
} & QueryContext['fetcherOptions'];

/**
 * 상품 삭제
 */
export const fetchDeleteProduct = (variables: DeleteProductVariables, signal?: AbortSignal) =>
  queryFetch<DeleteProductResponse, DeleteProductError, undefined, {}, {}, DeleteProductPathParams>(
    {
      url: '/{teamId}/products/{productId}',
      method: 'delete',
      ...variables,
      signal,
    },
  );

/**
 * 상품 삭제
 */
export const useDeleteProduct = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      DeleteProductResponse,
      DeleteProductError,
      DeleteProductVariables
    >,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useQueryContext();
  return reactQuery.useMutation<DeleteProductResponse, DeleteProductError, DeleteProductVariables>({
    mutationFn: (variables: DeleteProductVariables) =>
      fetchDeleteProduct(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type ListReviewsPathParams = {
  /**
   * @format double
   */
  productId: number;
  teamId: string;
};

export type ListReviewsQueryParams = {
  /**
   * 정렬 순서
   */
  order?: 'recent' | 'ratingDesc' | 'ratingAsc' | 'likeCount';
  /**
   * 다음 페이지를 위한 커서
   *
   * @format double
   */
  cursor?: number;
};

export type ListReviewsError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    message: string;
  };
}>;

export type ListReviewsVariables = {
  pathParams: ListReviewsPathParams;
  queryParams?: ListReviewsQueryParams;
} & QueryContext['fetcherOptions'];

/**
 * 상품 리뷰 목록 조회
 */
export const fetchListReviews = (variables: ListReviewsVariables, signal?: AbortSignal) =>
  queryFetch<
    Schemas.ListReviewResponse,
    ListReviewsError,
    undefined,
    {},
    ListReviewsQueryParams,
    ListReviewsPathParams
  >({
    url: '/{teamId}/products/{productId}/reviews',
    method: 'get',
    ...variables,
    signal,
  });

/**
 * 상품 리뷰 목록 조회
 */
export function listReviewsQuery(variables: ListReviewsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.ListReviewResponse>;
};

export function listReviewsQuery(variables: ListReviewsVariables | reactQuery.SkipToken): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.ListReviewResponse>)
    | reactQuery.SkipToken;
};

export function listReviewsQuery(variables: ListReviewsVariables | reactQuery.SkipToken) {
  return {
    queryKey: queryKeyFn({
      path: '/{teamId}/products/{productId}/reviews',
      operationId: 'listReviews',
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchListReviews(variables, signal),
  };
}

/**
 * 상품 리뷰 목록 조회
 */
export const useSuspenseListReviews = <TData = Schemas.ListReviewResponse>(
  variables: ListReviewsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.ListReviewResponse, ListReviewsError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueryContext(options);
  return reactQuery.useSuspenseQuery<Schemas.ListReviewResponse, ListReviewsError, TData>({
    ...listReviewsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * 상품 리뷰 목록 조회
 */
export const useListReviews = <TData = Schemas.ListReviewResponse>(
  variables: ListReviewsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.ListReviewResponse, ListReviewsError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueryContext(options);
  return reactQuery.useQuery<Schemas.ListReviewResponse, ListReviewsError, TData>({
    ...listReviewsQuery(
      variables === reactQuery.skipToken ? variables : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type UpsertOauthAppPathParams = {
  teamId: string;
};

export type UpsertOauthAppError = Fetcher.ErrorWrapper<undefined>;

export type UpsertOauthAppVariables = {
  body: Schemas.UpsertOauthAppRequestBody;
  pathParams: UpsertOauthAppPathParams;
} & QueryContext['fetcherOptions'];

/**
 * 간편 로그인 App 등록/수정<br/>
 * Google, Kakao 간편 로그인을 위한 App 을 등록하거나 수정합니다.<br/>
 * 이미 등록된 앱이 있을 경우 덮어씌워집니다.
 *
 * 요청 데이터 중 appKey 는 각 서비스에서 발급받은 인증 키 입니다.<br/>
 * Google 의 경우에는 <b>"클라이언트 id"</b> 입니다.<br/>
 * Kakao 의 경우에는 <b>"REST API 키"</b> 입니다.<br/>
 * 실습을 위해 발급받은 키를 등록해주세요. 실제 서비스에서 사용 하는 키를 등록해서는 안됩니다.
 */
export const fetchUpsertOauthApp = (variables: UpsertOauthAppVariables, signal?: AbortSignal) =>
  queryFetch<
    Schemas.OauthApp,
    UpsertOauthAppError,
    Schemas.UpsertOauthAppRequestBody,
    {},
    {},
    UpsertOauthAppPathParams
  >({ url: '/{teamId}/oauthApps', method: 'post', ...variables, signal });

/**
 * 간편 로그인 App 등록/수정<br/>
 * Google, Kakao 간편 로그인을 위한 App 을 등록하거나 수정합니다.<br/>
 * 이미 등록된 앱이 있을 경우 덮어씌워집니다.
 *
 * 요청 데이터 중 appKey 는 각 서비스에서 발급받은 인증 키 입니다.<br/>
 * Google 의 경우에는 <b>"클라이언트 id"</b> 입니다.<br/>
 * Kakao 의 경우에는 <b>"REST API 키"</b> 입니다.<br/>
 * 실습을 위해 발급받은 키를 등록해주세요. 실제 서비스에서 사용 하는 키를 등록해서는 안됩니다.
 */
export const useUpsertOauthApp = (
  options?: Omit<
    reactQuery.UseMutationOptions<Schemas.OauthApp, UpsertOauthAppError, UpsertOauthAppVariables>,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useQueryContext();
  return reactQuery.useMutation<Schemas.OauthApp, UpsertOauthAppError, UpsertOauthAppVariables>({
    mutationFn: (variables: UpsertOauthAppVariables) =>
      fetchUpsertOauthApp(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type ImageUploadPathParams = {
  teamId: string;
};

export type ImageUploadError = Fetcher.ErrorWrapper<undefined>;

export type ImageUploadResponse = {
  url: string;
};

export type ImageUploadRequestBody = {
  /**
   * 이미지 파일, 최대 용량은 5MB입니다.
   *
   * @format binary
   */
  image: Blob;
};

export type ImageUploadVariables = {
  body: ImageUploadRequestBody;
  pathParams: ImageUploadPathParams;
} & QueryContext['fetcherOptions'];

/**
 * 이미지 업로드,
 * 프로젝트에 저장하는 이미지들은 이 엔드포인트를 통해 업로드한 후 URL을 획득하여 사용합니다.
 */
export const fetchImageUpload = (variables: ImageUploadVariables, signal?: AbortSignal) =>
  queryFetch<
    ImageUploadResponse,
    ImageUploadError,
    ImageUploadRequestBody,
    {},
    {},
    ImageUploadPathParams
  >({ url: '/{teamId}/images/upload', method: 'post', ...variables, signal });

/**
 * 이미지 업로드,
 * 프로젝트에 저장하는 이미지들은 이 엔드포인트를 통해 업로드한 후 URL을 획득하여 사용합니다.
 */
export const useImageUpload = (
  options?: Omit<
    reactQuery.UseMutationOptions<ImageUploadResponse, ImageUploadError, ImageUploadVariables>,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useQueryContext();
  return reactQuery.useMutation<ImageUploadResponse, ImageUploadError, ImageUploadVariables>({
    mutationFn: (variables: ImageUploadVariables) =>
      fetchImageUpload(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type FollowPathParams = {
  teamId: string;
};

export type FollowError = Fetcher.ErrorWrapper<undefined>;

export type FollowVariables = {
  body: Schemas.FollowRequestBody;
  pathParams: FollowPathParams;
} & QueryContext['fetcherOptions'];

/**
 * 유저 팔로우
 */
export const fetchFollow = (variables: FollowVariables, signal?: AbortSignal) =>
  queryFetch<Schemas.UserDetail, FollowError, Schemas.FollowRequestBody, {}, {}, FollowPathParams>({
    url: '/{teamId}/follow',
    method: 'post',
    ...variables,
    signal,
  });

/**
 * 유저 팔로우
 */
export const useFollow = (
  options?: Omit<
    reactQuery.UseMutationOptions<Schemas.UserDetail, FollowError, FollowVariables>,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useQueryContext();
  return reactQuery.useMutation<Schemas.UserDetail, FollowError, FollowVariables>({
    mutationFn: (variables: FollowVariables) => fetchFollow(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type UnfollowPathParams = {
  teamId: string;
};

export type UnfollowError = Fetcher.ErrorWrapper<undefined>;

export type UnfollowVariables = {
  body: Schemas.FollowRequestBody;
  pathParams: UnfollowPathParams;
} & QueryContext['fetcherOptions'];

/**
 * 유저 언팔로우
 */
export const fetchUnfollow = (variables: UnfollowVariables, signal?: AbortSignal) =>
  queryFetch<
    Schemas.UserDetail,
    UnfollowError,
    Schemas.FollowRequestBody,
    {},
    {},
    UnfollowPathParams
  >({ url: '/{teamId}/follow', method: 'delete', ...variables, signal });

/**
 * 유저 언팔로우
 */
export const useUnfollow = (
  options?: Omit<
    reactQuery.UseMutationOptions<Schemas.UserDetail, UnfollowError, UnfollowVariables>,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useQueryContext();
  return reactQuery.useMutation<Schemas.UserDetail, UnfollowError, UnfollowVariables>({
    mutationFn: (variables: UnfollowVariables) =>
      fetchUnfollow(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type FavoritePathParams = {
  teamId: string;
  /**
   * 찜할 상품 ID
   *
   * @format double
   */
  productId: number;
};

export type FavoriteError = Fetcher.ErrorWrapper<undefined>;

export type FavoriteVariables = {
  pathParams: FavoritePathParams;
} & QueryContext['fetcherOptions'];

/**
 * 상품 찜하기
 */
export const fetchFavorite = (variables: FavoriteVariables, signal?: AbortSignal) =>
  queryFetch<Schemas.ProductDetailType, FavoriteError, undefined, {}, {}, FavoritePathParams>({
    url: '/{teamId}/products/{productId}/favorite',
    method: 'post',
    ...variables,
    signal,
  });

/**
 * 상품 찜하기
 */
export const useFavorite = (
  options?: Omit<
    reactQuery.UseMutationOptions<Schemas.ProductDetailType, FavoriteError, FavoriteVariables>,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useQueryContext();
  return reactQuery.useMutation<Schemas.ProductDetailType, FavoriteError, FavoriteVariables>({
    mutationFn: (variables: FavoriteVariables) =>
      fetchFavorite(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type UnfavoritePathParams = {
  teamId: string;
  /**
   * 찜할 상품 ID
   *
   * @format double
   */
  productId: number;
};

export type UnfavoriteError = Fetcher.ErrorWrapper<undefined>;

export type UnfavoriteVariables = {
  pathParams: UnfavoritePathParams;
} & QueryContext['fetcherOptions'];

/**
 * 상품 찜하기 취소
 */
export const fetchUnfavorite = (variables: UnfavoriteVariables, signal?: AbortSignal) =>
  queryFetch<Schemas.ProductDetailType, UnfavoriteError, undefined, {}, {}, UnfavoritePathParams>({
    url: '/{teamId}/products/{productId}/favorite',
    method: 'delete',
    ...variables,
    signal,
  });

/**
 * 상품 찜하기 취소
 */
export const useUnfavorite = (
  options?: Omit<
    reactQuery.UseMutationOptions<Schemas.ProductDetailType, UnfavoriteError, UnfavoriteVariables>,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useQueryContext();
  return reactQuery.useMutation<Schemas.ProductDetailType, UnfavoriteError, UnfavoriteVariables>({
    mutationFn: (variables: UnfavoriteVariables) =>
      fetchUnfavorite(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type ListAllCategoryError = Fetcher.ErrorWrapper<undefined>;

export type ListAllCategoryResponse = Schemas.Category[];

export type ListAllCategoryVariables = QueryContext['fetcherOptions'];

export const fetchListAllCategory = (variables: ListAllCategoryVariables, signal?: AbortSignal) =>
  queryFetch<ListAllCategoryResponse, ListAllCategoryError, undefined, {}, {}, {}>({
    url: '/{teamId}/categories',
    method: 'get',
    ...variables,
    signal,
  });

export function listAllCategoryQuery(variables: ListAllCategoryVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<ListAllCategoryResponse>;
};

export function listAllCategoryQuery(variables: ListAllCategoryVariables | reactQuery.SkipToken): {
  queryKey: reactQuery.QueryKey;
  queryFn: ((options: QueryFnOptions) => Promise<ListAllCategoryResponse>) | reactQuery.SkipToken;
};

export function listAllCategoryQuery(variables: ListAllCategoryVariables | reactQuery.SkipToken) {
  return {
    queryKey: queryKeyFn({
      path: '/{teamId}/categories',
      operationId: 'listAllCategory',
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchListAllCategory(variables, signal),
  };
}

export const useSuspenseListAllCategory = <TData = ListAllCategoryResponse>(
  variables: ListAllCategoryVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<ListAllCategoryResponse, ListAllCategoryError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueryContext(options);
  return reactQuery.useSuspenseQuery<ListAllCategoryResponse, ListAllCategoryError, TData>({
    ...listAllCategoryQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useListAllCategory = <TData = ListAllCategoryResponse>(
  variables: ListAllCategoryVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<ListAllCategoryResponse, ListAllCategoryError, TData>,
    'queryKey' | 'queryFn' | 'initialData'
  >,
) => {
  const { queryOptions, fetcherOptions } = useQueryContext(options);
  return reactQuery.useQuery<ListAllCategoryResponse, ListAllCategoryError, TData>({
    ...listAllCategoryQuery(
      variables === reactQuery.skipToken ? variables : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type SignUpPathParams = {
  teamId: string;
};

export type SignUpError = Fetcher.ErrorWrapper<undefined>;

export type SignUpVariables = {
  body: Schemas.SignUpRequestBody;
  pathParams: SignUpPathParams;
} & QueryContext['fetcherOptions'];

/**
 * 회원가입
 */
export const fetchSignUp = (variables: SignUpVariables, signal?: AbortSignal) =>
  queryFetch<
    Schemas.SignUpResponse,
    SignUpError,
    Schemas.SignUpRequestBody,
    {},
    {},
    SignUpPathParams
  >({ url: '/{teamId}/auth/signUp', method: 'post', ...variables, signal });

/**
 * 회원가입
 */
export const useSignUp = (
  options?: Omit<
    reactQuery.UseMutationOptions<Schemas.SignUpResponse, SignUpError, SignUpVariables>,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useQueryContext();
  return reactQuery.useMutation<Schemas.SignUpResponse, SignUpError, SignUpVariables>({
    mutationFn: (variables: SignUpVariables) => fetchSignUp(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type SignInError = Fetcher.ErrorWrapper<undefined>;

export type SignInVariables = {
  body: Schemas.SignInRequestBody;
} & QueryContext['fetcherOptions'];

/**
 * 로그인
 */
export const fetchSignIn = (variables: SignInVariables, signal?: AbortSignal) =>
  queryFetch<Schemas.SignInResponse, SignInError, Schemas.SignInRequestBody, {}, {}, {}>({
    url: '/{teamId}/auth/signIn',
    method: 'post',
    ...variables,
    signal,
  });

/**
 * 로그인
 */
export const useSignIn = (
  options?: Omit<
    reactQuery.UseMutationOptions<Schemas.SignInResponse, SignInError, SignInVariables>,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useQueryContext();
  return reactQuery.useMutation<Schemas.SignInResponse, SignInError, SignInVariables>({
    mutationFn: (variables: SignInVariables) => fetchSignIn(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type SignUpOauthPathParams = {
  teamId: string;
  provider: Schemas.OauthProvider;
};

export type SignUpOauthError = Fetcher.ErrorWrapper<undefined>;

export type SignUpOauthVariables = {
  body?: Schemas.SignUpWithOauthRequestBody;
  pathParams: SignUpOauthPathParams;
} & QueryContext['fetcherOptions'];

/**
 * 간편 회원가입
 */
export const fetchSignUpOauth = (variables: SignUpOauthVariables, signal?: AbortSignal) =>
  queryFetch<
    Schemas.SignUpResponse,
    SignUpOauthError,
    Schemas.SignUpWithOauthRequestBody,
    {},
    {},
    SignUpOauthPathParams
  >({
    url: '/{teamId}/auth/signUp/{provider}',
    method: 'post',
    ...variables,
    signal,
  });

/**
 * 간편 회원가입
 */
export const useSignUpOauth = (
  options?: Omit<
    reactQuery.UseMutationOptions<Schemas.SignUpResponse, SignUpOauthError, SignUpOauthVariables>,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useQueryContext();
  return reactQuery.useMutation<Schemas.SignUpResponse, SignUpOauthError, SignUpOauthVariables>({
    mutationFn: (variables: SignUpOauthVariables) =>
      fetchSignUpOauth(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type SignInOauthPathParams = {
  teamId: string;
  provider: Schemas.OauthProvider;
};

export type SignInOauthError = Fetcher.ErrorWrapper<{
  status: 403;
  payload: {
    message: string;
  };
}>;

export type SignInOauthVariables = {
  body: Schemas.SignInWithOauthRequestBody;
  pathParams: SignInOauthPathParams;
} & QueryContext['fetcherOptions'];

/**
 * 간편 로그인
 */
export const fetchSignInOauth = (variables: SignInOauthVariables, signal?: AbortSignal) =>
  queryFetch<
    Schemas.SignInResponse,
    SignInOauthError,
    Schemas.SignInWithOauthRequestBody,
    {},
    {},
    SignInOauthPathParams
  >({
    url: '/{teamId}/auth/signIn/{provider}',
    method: 'post',
    ...variables,
    signal,
  });

/**
 * 간편 로그인
 */
export const useSignInOauth = (
  options?: Omit<
    reactQuery.UseMutationOptions<Schemas.SignInResponse, SignInOauthError, SignInOauthVariables>,
    'mutationFn'
  >,
) => {
  const { fetcherOptions } = useQueryContext();
  return reactQuery.useMutation<Schemas.SignInResponse, SignInOauthError, SignInOauthVariables>({
    mutationFn: (variables: SignInOauthVariables) =>
      fetchSignInOauth(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type QueryOperation =
  | {
      path: '/{teamId}/users/me';
      operationId: 'me';
      variables: MeVariables | reactQuery.SkipToken;
    }
  | {
      path: '/{teamId}/users/ranking';
      operationId: 'userRanking';
      variables: UserRankingVariables | reactQuery.SkipToken;
    }
  | {
      path: '/{teamId}/users/{userId}';
      operationId: 'userDetail';
      variables: UserDetailVariables | reactQuery.SkipToken;
    }
  | {
      path: '/{teamId}/users/{userId}/created-products';
      operationId: 'listUserCreatedProducts';
      variables: ListUserCreatedProductsVariables | reactQuery.SkipToken;
    }
  | {
      path: '/{teamId}/users/{userId}/reviewed-products';
      operationId: 'listUserReviewedProducts';
      variables: ListUserReviewedProductsVariables | reactQuery.SkipToken;
    }
  | {
      path: '/{teamId}/users/{userId}/favorite-products';
      operationId: 'listUserFavoriteProducts';
      variables: ListUserFavoriteProductsVariables | reactQuery.SkipToken;
    }
  | {
      path: '/{teamId}/users/{userId}/followees';
      operationId: 'listUserFollowees';
      variables: ListUserFolloweesVariables | reactQuery.SkipToken;
    }
  | {
      path: '/{teamId}/users/{userId}/followers';
      operationId: 'listUserFollowers';
      variables: ListUserFollowersVariables | reactQuery.SkipToken;
    }
  | {
      path: '/{teamId}/products';
      operationId: 'listProduct';
      variables: ListProductVariables | reactQuery.SkipToken;
    }
  | {
      path: '/{teamId}/products/{productId}';
      operationId: 'retrieveProduct';
      variables: RetrieveProductVariables | reactQuery.SkipToken;
    }
  | {
      path: '/{teamId}/products/{productId}/reviews';
      operationId: 'listReviews';
      variables: ListReviewsVariables | reactQuery.SkipToken;
    }
  | {
      path: '/{teamId}/categories';
      operationId: 'listAllCategory';
      variables: ListAllCategoryVariables | reactQuery.SkipToken;
    };
